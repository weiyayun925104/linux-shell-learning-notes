简介

Hello World

打开文本编辑器，新建一个文件test.sh，扩展名为.sh（sh代表shell）。

输入一些代码：

#!/bin/bash
echo "Hello World !"

在命令行运行：

chmod +x test.sh
./test.sh

运行结果：

Hello World !

#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。
注释

以#开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。

# --------
# 这是注释块
# --------

打印输出

echo： 是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。

echo arg 
echo -e arg
echo arg > myfile

printf：格式化输出语句。 printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。

如同 echo 命令，printf 命令也可以输出简单的字符串:

printf "hello\n"

printf 不像 echo 那样会自动换行，必须显式添加换行符(\n)。

注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。

printf 命令的语法：

printf  format-string  [arguments...]

#format-string 为格式控制字符串，arguments 为参数列表。功能和用法与c语言的 printf 命令类似。

这里仅说明与C语言printf()函数的不同：

    printf 命令不用加括号
    format-string 可以没有引号，但最好加上，单引号双引号均可。
    参数比格式控制符(%)多时，格式控制符可以重用，可以将所有参数都转换。
    arguments 使用空格分隔，不用逗号。

# 双引号
printf "%d %s\n" 10 "abc"
10 abc
# 单引号与双引号效果一样 
printf '%d %s\n' 10 "abc" 
10 abc

# 没有引号也可以输出
printf %s abc
abc

# 但是下面的会出错：
printf %d %s 10 abc 
#因为系统分不清楚哪个是参数，这时候最好加引号了。


# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
$ printf %s a b c
abc
$ printf "%s\n" a b c
a
b
c

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
$ printf "%s and %d \n" 
and 0

# 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0
$ printf "The first program always prints'%s,%d\n'" Hello Shell
-bash: printf: Shell: invalid number
The first program always prints 'Hello,0'
$

read： 命令行从输入设备读入内容

#!/bin/bash

# Author : lalal

echo "What is your name?"
read NAME #输入
echo "Hello, $NAME"

运行脚本：

chmod +x test.sh
./test.sh

What is your name?
lalal

Hello, lalal

变量定义

Shell支持自定义变量。
定义变量

定义变量时，变量名不加美元符号（$），如：

variableName="value"

注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。有空格会出错。

同时，变量名的命名须遵循如下规则：

        首个字符必须为字母（a-z，A-Z）。

    中间不能有空格，可以使用下划线（_）。
    不能使用标点符号。
    不能使用bash里的关键字（可用help命令查看保留关键字）。

变量定义举例：

myUrl="lalal"
myNum=100

    注意：变量中间不能有空格，如果手误写错(例如 var = test)，刚好要使用rm -rf $var/删除这个目录，实际执行的是rm -rf /。

使用变量

使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，如：

your_name="lalal"
echo $your_name
echo ${your_name}

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：

for skill in C PHP Python Java 
do
    echo "I am good at ${skill}Script"
done

如果不给skill变量加花括号，写成echo "I am good at $skillScript"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。

推荐给所有变量加上花括号，这是个好的编程习惯。

    已定义的变量，可以被重新定义。

在变量前面加readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

url="http://www.baidu.com"
readonly url
url="http://www.baidu.com"

使用 unset 命令可以删除变量。语法：

unset variable_name

变量被删除后不能再次使用；unset 命令不能删除只读变量。
变量类型

运行shell时，会同时存在三种变量： 1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。

2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。

3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。
特殊变量

前面已经讲到，变量名只能包含数字、字母和下划线，因为某些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。
变量 	含义
$0 	当前脚本的文件名
$n 	传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
$# 	传递给脚本或函数的参数个数。
$* 	传递给脚本或函数的所有参数。
$@ 	传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同
$? 	上个命令的退出状态，或函数的返回值。
$$ 	当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。

示例：

#!/bin/bash
echo "File Name: $0"
echo "First Parameter : $1"
echo "Second Parameter : $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters : $#"

运行结果：

$./test.sh Zara Ali
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2

$* 和 $@ 的区别

$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"$1" "$2" … "$n" 的形式输出所有参数。

但是当它们被双引号(" ")包含时，"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数。

示例：

#!/bin/bash
echo "\$*=" $*
echo "\"\$*\"=" "$*"
echo "\$@=" $@
echo "\"\$@\"=" "$@"
echo "print each param from \$*"
for var in $*
do
    echo "$var"
done
echo "print each param from \$@"
for var in $@
do
    echo "$var"
done
echo "print each param from \"\$*\""
for var in "$*"
do
    echo "$var"
done
echo "print each param from \"\$@\""
for var in "$@"
do
    echo "$var"
done

执行 ./test.sh "a" "b" "c" "d"，看到下面的结果：

$*=  a b c d
"$*"= a b c d
$@=  a b c d
"$@"= a b c d
print each param from $*
a
b
c
d
print each param from $@
a
b
c
d
print each param from "$*"
a b c d
print each param from "$@"
a
b
c
d

退出状态

$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。

示例：

if [[ $? != 0 ]];then
  echo "error"
  exit 1;
fi

退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。

不过，也有一些命令返回其他值，表示不同类型的错误。
转义字符

转义字符	含义
\\	反斜杠
\a	警报，响铃
\b	退格（删除键）
\f	换页(FF)，将当前位置移到下页开头
\n	换行
\r	回车
\t	水平制表符（tab键） 
\v	垂直制表符

shell默认是不转义上面的字符的。需要加-e选项。

举个例子：

#!/bin/bash
a=11
echo -e "a is $a \n"

运行结果：

a is 11

这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出：

a is 11\n

可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。
命令替换

命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。

语法：

`command`

注意是反引号，不是单引号，这个键位于 Esc 键下方。

下面的例子中，将命令执行结果保存在变量中：

#!/bin/bash
DATE=`date`
echo "Date is $DATE"

变量替换

变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值。

可以使用的变量替换形式：
形式 	说明
${var} 	变量本来的值
${var:-word} 	如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。
${var:=word} 	如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。
${var:?message} 	如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。
${var:+word} 	如果变量 var 被定义，那么返回 word，但不改变 var 的值。
一个完整的shell示例

下面的脚本用于php安装过程中安装zip扩展。

php_zip_ins.sh

#!/bin/bash
#zip install

if [ -d php-5.4.25/ext/zip ];then
	cd php-5.4.25/ext/zip
else
	tar zxvf php-5.4.25.tar.gz
	cd php-5.4.25/ext/zip
fi
/usr/local/php/bin/phpize
./configure --with-php-config=/usr/local/php/bin/php-config
make
[ $? != 0 ] && exit
make install
echo 
grep 'no-debug-zts-20100525' /usr/local/php/etc/php.ini
if [ $? != 0 ];then
        echo '' >> /usr/local/php/etc/php.ini
        echo 'extension_dir=/usr/local/php/lib/php/extensions/no-debug-zts-20100525' >> /usr/local/php/etc/php.ini
fi
grep 'zip.so' /usr/local/php/etc/php.ini
if [ $? != 0 ];then
	echo 'extension=zip.so' >> /usr/local/php/etc/php.ini
fi
echo "zip install is OK"


/usr/local/apache2/bin/apachectl restart
cd -
rm -rf php-5.4.25
echo "all ok!"
ls /usr/local/php/lib/php/extensions/no-debug-zts-20100525/

Shell运算符

Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。
算术运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

# 命令行直接计算
expr 2 + 2   #4
expr 3 - 2   #1
expr 3 / 2   #1
expr 3 \* 2   #6

# 使用表达式
a=10
b=20
val=`expr $a + $b`
echo "a + b : $val"

注意：

    表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
    乘号(*)前边必须加反斜杠(\)才能实现乘法运算
    完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。

算术运算符列表

运算符	说明	    举例
+	    加法	`expr $a + $b` 结果为 30。
-   	减法	`expr $a - $b` 结果为 10。
*	    乘法	`expr $a \* $b` 结果为  200。
/	    除法	`expr $b / $a` 结果为 2。
%	    取余	`expr $b % $a` 结果为 0。
=	    赋值	a=$b 将把变量 b 的值赋给 a。
==	    相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。
!=	    不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。

关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

#!/bin/sh
a=10
b=20
if [ $a -eq $b ]
then
   echo "$a -eq $b : a is equal to b"
else
   echo "$a -eq $b: a is not equal to b"
fi

缩成一行可以这样：

a=10;b=20;if [ $a -eq $b ];then echo "$a -eq $b : a is equal to b"; else echo "$a -eq $b: a is not equal to b"; fi

这里缩写，主要是为了让大家注意：

    if后面直到then前面的分号结束，都是有空格的: if [ $a -eq $b ]

关系运算符列表

运算符	说明
-eq	检测两个数是否相等，相等返回 true。同算数运算符`==`
-ne	检测两个数是否相等，不相等返回 true
-gt	检测左边的数是否大于右边的，如果是，则返回 true。
-lt	检测左边的数是否小于右边的，如果是，则返回 true。
-ge	检测左边的数是否大等于右边的，如果是，则返回 true。
-le	检测左边的数是否小于等于右边的，如果是，则返回 true。

布尔运算符

布尔运算符列表

运算符	说明
!	非运算，表达式为 true 则返回 false，否则返回 true。
-o	或运算(or)，有一个表达式为 true 则返回 true。
-a	与运算(and)，两个表达式都为 true 才返回 true。

if [ 3 -eq 3 -a 3 -lt 5 ]
then
    echo 'ok'
fi;

字符串运算符

字符串运算符列表

运算符	说明	举例
=	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。
!=	检测两个字符串是否相等，不相等返回 true。	[ $a != $b ] 返回 true。
-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。
-n	检测字符串长度是否为0，不为0返回 true。	[ -n $a ] 返回 true。
str	检测字符串是否为空，不为空返回 true。	[ $a ] 返回 true。

文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

#!/bin/sh
file="/tmp/test.sh"

if [ -e $file ]
then
   echo "File exists"
else
   echo "File does not exist"
fi

文件测试运算符列表

操作符	说明	举例

-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 返回 false。

-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 返回 false。

-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。

-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。

-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ] 返回 false。

-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 返回 false。

-p file	检测文件是否是具名管道，如果是，则返回 true。	[ -p $file ] 返回 false。

-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 返回 false。

-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 返回 true。

-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 返回 true。

-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 返回 true。

-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 返回 true。

-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 返回 true。

字符串

字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。

拼接字符串

#!/bin/bash

str1='i'
str2='love'
str3='you'

echo $str1 $str2 $str3
echo $str1$str2$str3
echo $str1,$str2,$str3

输出：

i love you
iloveyou
i,love,you

获取字符串长度

#!/bin/bash/

str='i love you'

echo ${#str}

# 输出：10

截取字符串

#!/bin/bash/

str='i love you'

echo ${str:1} # 从第1个截取到末尾。注意从0开始。
echo ${str:2:2} # 从第2个截取2个。
echo ${str:0} # 全部截取。
echo ${str:-3} # 负数无效，视为0。

输出：

love you
lo
i love you
i love you

查找字符串

#!/bin/bash/

str="i love you"

echo `expr index "$str" l`
echo `expr index "$str" you` #最后一个参数是字符，会对后面字符串每一个单独查找，返回最靠前的index
echo `expr index "$str" o`
echo `expr length "$str"` #字符串长度
echo `expr substr "$str" 1 6` #从字符串中位置1开始截取6个字符。索引是从0开始的。

输出:

3
4
4
10
i love

注意字符串变量需要加双引号。第2个例子里you虽然y的index是8,但是o在前面已经出现过,index是4，最终取所有字符里最靠前的index。

*拓展：expr更多关于字符串用法：

STRING : REGEXP   anchored pattern match of REGEXP in STRING

match STRING REGEXP        same as STRING : REGEXP

substr STRING POS LENGTH   #从STRING中POS位置开始截取LENGTH个字符。POS索引是从1开始的。

index STRING CHARS         #在STRING中查找字符CHARS首次出现的位置，没有找到返回0

length STRING              #字符串长度

数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。

在Shell中，用括号来表示数组，数组元素用空格符号分割开。定义数组的一般形式为：

array_name=(value1 value2 ... valuen)

例如：

array_name=(value0 value1 value2 value3)

或者

array_name=(
    value0
    value1
    value2
    value3
)

还可以单独定义数组的各个分量：

array_name[0]=value0
array_name[1]=value1
array_name[2]=value2

可以不使用连续的下标，而且下标的范围没有限制。

下面来读取数组：

echo ${array_name[2]} #读取下标为2的元素
echo ${array_name[*]} #读取所有元素
echo ${array_name[@]} #读取所有元素


echo ${#array_name[*]} #获取数组长度
echo ${#array_name[@]} #获取数组长度
echo ${#array_name[1]} #获取数组中单个元素的长度

输出：

value2
value0 value1 value2 value3
value0 value1 value2 value3
4
4
6

总结

对比shell里字符串和数组，我们发现：

字符串

str="hello"
${#str} # 读取字符串长度
echo ${str} # 读取字符串全部
echo ${str:1} # 截取字符串

数组：

arr=(a1 a2 a3)
echo ${#arr[*]} # 读取数组长度
echo ${#arr[1]} # 读取数组某个元素长度

echo ${arr[*]} # 读取数组全部
echo ${arr[1]} # 读取数组某个元素

${#ele*}用来读取ele元素长度属性
${ele*}用来读取或操作ele元素

条件判断：if语句

语法格式：

if [ expression ]
then
   Statement(s) to be executed if expression is true
fi

注意：expression 和方括号([ ])之间必须有空格，否则会有语法错误。

if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if ... else 语句：

if ... fi 语句
if ... else ... fi 语句
if ... elif ... else ... fi 语句

示例：

#!/bin/bash/

a=10
b=20
if [ $a == $b ]
then 
	echo "a is equal to b"
elif [ $a -gt $b ]
then
	echo "a is greater to b"
else
	echo "a is less to b"
fi

if ... else 语句也可以写成一行，以命令的方式来运行:

a=10;b=20;if [ $a == $b ];then echo "a is equal to b";else echo "a is not equal to b";fi;

if ... else 语句也经常与 test 命令结合使用，作用与上面一样：

#!/bin/bash/

a=10
b=20
if test $a == $b 
then 
	echo "a is equal to b"
else
	echo "a is not equal to b"
fi

分支控制：case语句

case ... esac 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构。

示例：

#!/bin/bash/

grade="B"

case $grade in 
	"A") echo "Very Good!";;
	"B") echo "Good!";;
	"C") echo "Come On!";;
	*) 
		echo "You Must Try!"
		echo "Sorry!";;
esac

转换成C语言是：

#include <stdio.h>
int main(){
    char grade = 'B';
    switch(grade){
        case 'A': printf("Very Good!");break;
        case 'B': printf("Very Good!");break;
        case 'C': printf("Very Good!");break;
        default: 
            printf("You Must Try!");
            printf("Sorry!");
            break;
    }
    return 0;
}

对比看就很容易理解了。很相似，只是格式不一样。

需要注意的是： 取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。

取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。

再举一个例子：

#!/bin/bash
option="${1}"
case ${option} in
   "-f") FILE="${2}"
      echo "File name is $FILE"
      ;;
   "-d") DIR="${2}"
      echo "Dir name is $DIR"
      ;;
   *) 
      echo "`basename ${0}`:usage: [-f file] | [-d directory]"
      exit 1 # Command to come out of the program with status 1
      ;;
esac

运行结果：

$./test.sh
test.sh: usage: [ -f filename ] | [ -d directory ]

./test.sh -f index.html
File name is index.html

这里用到了特殊变量${1},指的是获取命令行的第一个参数。

下面结合getopts命令介绍下一个经典的例子：从命令行读取参数。

run.sh

#!/bin/sh

usage()
{
    echo "Usage: $0 -s [start|stop|reload|restart] -e [online|test]"
    exit 1
}

if [ -z $1 ]; then
    usage
fi

while getopts 's:e:h' OPT; do
    case $OPT in
        s) cmd="$OPTARG";;
        e) env="$OPTARG";;
        h) usage;;
        ?) usage;;
    esac
done

echo $cmd
echo $env

当我们直接运行run.sh的时候，会调用usage显示帮助；如果输入正确的参数，则会进入正确的流程。运行示例：

sh run.sh -s start -e test

for循环

shell的for循环与c、php等语言不同，同Python很类似。下面是语法格式：

for 变量 in 列表
do
    command1
    command2
    ...
    commandN
done

示例：

#!/bin/bash/

for value in 1 2 3 4 5
do 
	echo "The value is $value"
done

输出：

The value is 1
The value is 2
The value is 3
The value is 4
The value is 5

顺序输出字符串中的字符：

for str in 'This is a string'
do
    echo $str
done

运行结果：

This is a string

遍历目录下的文件：

#!/bin/bash
for FILE in *
do
   echo $FILE
done

上面的代码将遍历当前目录下所有的文件。在Linux下，可以改为其他目录试试。

遍历文件内容： city.txt

beijing
tianjin
shanghai

#!/bin/bash

citys=`cat city.txt`
for city in $citys
do
   echo $city
done

输出：

beijing
tianjin
shanghai

while循环

只要while后面的条件满足，就一直执行do里面的代码块。

其格式为：

while command
do
   Statement(s) to be executed if command is true
done

命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。

示例：

#!/bin/bash

c=0;
while [ $c -lt 3 ]
do
	echo "Value c is $c"
	c=`expr $c + 1`
done

输出：

Value c is 0
Value c is 1
Value c is 2

这里由于shell本身不支持算数运算，所以使用expr命令进行自增。
until循环

until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。

将上面while循环的例子改改，就能达到一样的效果：

#!/bin/bash

c=0;
until [ $c -eq 3 ]
do
	echo "Value c is $c"
	c=`expr $c + 1`
done

首先do里面的语句块一直在运行，直到满足了until的条件就停止。

输出：

Value c is 0
Value c is 1
Value c is 2

跳出循环

在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。
break

break命令允许跳出所有循环（终止执行后面的所有循环）。

#!/bin/bash

i=0
while [ $i -lt 5 ]
do
	i=`expr $i + 1`

	if [ $i == 3 ]
	then
		break
	fi
	echo -e $i
done

运行结果：

1
2

在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：

break n

表示跳出第 n 层循环。
continue

continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。

#!/bin/bash

i=0
while [ $i -lt 5 ]
do
	i=`expr $i + 1`

	if [ $i == 3 ]
	then
		continue
	fi
	echo -e $i
	
done

运行结果：

1
2
4
5

函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。
函数定义

Shell 函数的定义格式如下：

function function_name () {
    list of commands
    [ return value ]
}

其中function关键字是可选的。

#!/bin/bash

hello(){
	echo 'hello';
}

hello

运行结果：

hello

调用函数只需要给出函数名，不需要加括号。

函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。

Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：numeric argument required。

#!/bin/bash

function hello(){
	return 'hello';
}

hello

运行结果：

line 4: return: hello: numeric argument required

如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。

#!/bin/bash

function hello(){
	return 'hello';
}

str=hello

echo $str

运行结果：

hello

像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 -f 选项，如下所示：

$unset -f function_name

如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。
函数参数

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...这就是前面讲的特殊变量。

#!/bin/bash

function sum(){
	case $# in 
		0) echo "no param";;
		1) echo $1;;
		2) echo `expr $1 + $2`;;
		3) echo `expr $1 + $2 + $3`;;
		*) echo "$# params! It's too much!";;
	esac
}

sum 1 3 5 6

运行结果：

4 params! It's too much!

注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。

另外，还有几个特殊变量用来处理参数，前面已经提到：

特殊变量	说明
$#	传递给函数的参数个数。
$*	显示所有传递给函数的参数。
$@	与$*相同，但是略有区别，请查看Shell特殊变量。
$?	函数的返回值。

如何获取函数返回值

后面的变量需要使用函数的返回值，怎么实现？

示例：

#!/bin/bash

function sum()
{
	echo `expr 1 + 2 + 3`
}

num=$(sum)

这样就可以取到返回值了。

Shell输入输出重定向

Unix 命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。 
输出重定向

命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。

命令输出重定向的语法为：

command > file

这样，输出到显示器的内容就可以被重定向到文件。

例如，下面的命令在显示器上不会看到任何输出：

who > users

打开 users 文件，可以看到下面的内容：

cat users

oko         tty01   Sep 12 07:30
ai          tty15   Sep 12 13:32
ruth        tty21   Sep 12 10:10
pat         tty24   Sep 12 13:07
steve       tty25   Sep 12 13:03

输出重定向会覆盖文件内容，请看下面的例子：

echo line 1 > users

cat users
line 1

如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：

echo line 2 >> users

cat users
line 1
line 2

输入重定向

和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：

command < file

这样，本来需要从键盘获取输入的命令会转移到文件读取内容。

注意：输出重定向是大于号(>)，输入重定向是小于号(<)。

例如，计算 users 文件中的行数，可以使用下面的命令：

wc -l users
2 users

也可以将输入重定向到 users 文件：

wc -l < users
2

注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。
重定向深入讲解

一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：

    标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
    标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
    标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。

默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。

如果希望 stderr 重定向到 file，可以这样写：

command 2 > file

如果希望 stderr 追加到 file 文件末尾，可以这样写：

command 2 >> file

2 表示标准错误文件(stderr)。

如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：

command > file 2>&1

如果希望对 stdin 和 stdout 都重定向，可以这样写：

command < file1 >file2

command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。

全部可用的重定向命令列表：

命令	说明
command > file	将输出重定向到 file。
command < file	将输入重定向到 file。
command >> file	将输出以追加的方式重定向到 file。
n > file	将文件描述符为 n 的文件重定向到 file。
n >> file	将文件描述符为 n 的文件以追加的方式重定向到 file。
n >& m	将输出文件 m 和 n 合并。
n <& m	将输入文件 m 和 n 合并。
<< tag	将开始标记 tag 和结束标记 tag 之间的内容作为输入。

Here Document

Here Document 目前没有统一的翻译，这里暂译为嵌入文档。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：

command << delimiter
    document
delimiter

它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。

注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。

开始的delimiter前后的空格会被忽略掉。

下面的例子，通过 wc -l 命令计算 document 的行数：

wc -l << EOF
    This is a simple lookup program
    for good (and bad) restaurants
    in Cape Town.
EOF

输出： 3

也可以 将 Here Document 用在脚本中，例如：

#!/bin/bash
cat << EOF
This is a simple lookup program
for good (and bad) restaurants
in Cape Town.
EOF

运行结果：

This is a simple lookup program
for good (and bad) restaurants
in Cape Town.

/dev/null 文件

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

command > /dev/null

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到禁止输出的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

command > /dev/null 2>&1

这样不会在屏幕打印任何信息。
Shell文件包含

像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。

Shell 中包含脚本可以使用 . filename 或 source filename 。

两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。

示例： 被包含文件：sub.sh

name="yjc"

主文件：test.sh

. ./sub.sh
echo $name

运行结果：

yjc

获取当前正在执行脚本的绝对路径

正确的命令是：

basepath=$(cd `dirname $0`; pwd)

直接使用pwd或者dirname $0是不对的。
按特定字符串截取字符串

示例：截取/www/html/php/myapp/里的myapp。

方案：

str=/www/html/php/myapp/
b=($(echo $str|sed 's#/# #g'))
b_len=`expr ${#b[*]} - 1`
app_name=${b[$b_len]}
echo $app_name

这里利用sed将字符串按指定字符截成数组，然后取最后一个。

计算数组长度：${#arr[*]}
计算则需要使用expr命令
awk
awk简介

awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件(或其他方式的输入流, 如重定向输入)逐行的读入（看作一个记录集）, 
把每一行看作一条记录，以空格(或\t,或用户自己指定的分隔符)为默认分隔符将每行切片（类似字段），切开的部分再进行各种分析处理。

awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。

Awk基本语法:　

awk 'pattern1 {command1;command 2…; command 3}  pattern2 { command …}'

pattern表示用来过滤记录的模式,可是是正则表达式，关系运算表达式，也可以什么也没有(表示选中所有记录)。

每个pattern选中的行记录会被花括号括起来的命令command操作一遍, command之间用;分割。 花括号里面可以什么也没有, 则默认为print输出整行记录。 Comamnd可以是输出， 可以是算术运算，逻辑运算，循环控制等等。
示例

s.txt

zhangsan 1977 male computer 83
lisi 1989 male math 99
wanglijiang 1990 female chinese 78
xuliang 1977 male economic 89
xuxin 1986 female english 99
wangxuebing 1978 male math 89
lichang 1989 male math 99
wanglijiang 1990 female chinese 78
zhangsansan 1977 male computer 83 
langxuebing 1978 male math 89
lisibao 1989 male math 99
xiaobao 1990 female chinese 78

一行中的5个字段分别表示姓名, 出生年, 性别,科目,分数, 是一个很传统很典型的报表文件。

现在演示awk是如何查找的：

1)直接输出1990年出生的同学:

$ awk '/1990/' s.txt

wanglijiang 1990 female chinese 78
wanglijiang 1990 female chinese 78
xiaobao 1990 female chinese 78
 

或者：

$ awk '/1990/{print $0}' s.txt

awk默认把输入的内容以空格拆分出每列。$0表示匹配所有列，print $0将输出所有列，每列分隔符是空格。

2）对chinese的课程的行输出"语文"：

$ awk '/chinese/{print "语文"}' s.txt

语文
语文
语文

3）记录的头部和结尾加上一段说明：

$ awk 'BEGIN{print "Result of the quiz:\n"}{print $0}END{print "------"}' s.txt
Result of the quiz:

zhangsan 1977 male computer 83
lisi 1989 male math 99
wanglijiang 1990 female chinese 78
xuliang 1977 male economic 89
xuxin 1986 female english 99
wangxuebing 1978 male math 89
lichang 1989 male math 99
wanglijiang 1990 female chinese 78
zhangsansan 1977 male computer 83
langxuebing 1978 male math 89
lisibao 1989 male math 99
xiaobao 1990 female chinese 78
------

AWK工作流程：逐行扫描文件，从第一行到最后一行，寻找匹配特定模式的行，并在这些行上进行用户想要到的操作。

BEGIN只会在最开始执行；END只会在扫描所有行数之后执行。BEGIN和END之间的花括号的内容每扫描一行都会执行。

4)查找女生的成绩且只输出姓名、学科、成绩：

$ awk '$3=="female"{print $1,$4,$5}' s.txt
wanglijiang chinese 78
xuxin english 99
wanglijiang chinese 78
xiaobao chinese 78

$1表示第1列，$n类推。这里条件是表达式，而不是正则。print里,表示空格分隔符。

5)找出1990年出生的学生姓名，并要求匹配正则:

$ awk '$2~/1990/{print $1}' s.txt
wanglijiang
wanglijiang
xiaobao

这里~表示匹配正则表达式。!~表示不匹配正则表达式。

如果需要多选，则改成：

$ awk '$2~/(1990|1991)/{print $1}' s.txt

简介
什么是 shell

    Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。
    Shell 既是一种命令语言，又是一种程序设计语言。
    Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。

Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。
什么是 shell 脚本

Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 .sh。

业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。
Shell 环境

Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。

Shell 的解释器种类众多，常见的有：

    sh - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。
    bash - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。
    fish - 智能和用户友好的命令行 shell。
    xiki - 使 shell 控制台更友好，更强大。
    zsh - 功能强大的 shell 与脚本语言。

指定脚本解释器

在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。

所以，你应该会在 shell 中，见到诸如以下的注释：

    指定 sh 解释器

#!/bin/sh

    指定 bash 解释器

#!/bin/bash

    注意

    上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：

    #!/usr/bin/env bash

    这样做的好处是，系统会自动在 PATH 环境变量中查找你指定的程序（本例中的bash）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。
    这样写还有一个好处，操作系统的PATH变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的bash，我们可能将其路径添加到PATH中，来“隐藏”老版本。
    如果直接用#!/bin/bash，那么系统会选择老版本的bash来执行脚本，如果用#!/usr/bin/env bash，则会使用新版本。

模式

shell 有交互和非交互两种模式。
交互模式

    简单来说，你可以将 shell 的交互模式理解为执行命令行。

看到形如下面的东西，说明 shell 处于交互模式下：

user@host:~$

接着，便可以输入一系列 Linux 命令，比如 ls，grep，cd，mkdir，rm 等等。
非交互模式

    简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。

在非交互模式下，shell 从文件或者管道中读取命令并执行。

当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。

可以使用下面的命令让 shell 以非交互模式运行：

sh /path/to/script.sh
bash /path/to/script.sh
source /path/to/script.sh
. /path/to/script.sh

上面的例子中，script.sh是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，sh和bash是 shell 解释器程序。你可以使用任何喜欢的编辑器创建script.sh（vim，nano，Sublime Text, Atom 等等）。

其中，source /path/to/script.sh 和 . /path/to/script.sh 是等价的。

除此之外，你还可以通过chmod命令给文件添加可执行的权限，来直接执行脚本文件：

chmod +x /path/to/script.sh #使脚本具有执行权限
/path/to/test.sh

这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：

💻 『示例源码』

#!/usr/bin/env bash
echo "Hello, world!"

上面的例子中，我们使用了一个很有用的命令echo来输出字符串到屏幕上。
基本语法
解释器

前面虽然两次提到了#! ，但是本着重要的事情说三遍的精神，这里再强调一遍：

在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。

#! 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入sh, bash, python, php等。

# 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好
#!/bin/bash
#!/usr/bin/env bash

注释

注释可以说明你的代码是什么作用，以及为什么这样写。

shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。

    单行注释 - 以 # 开头，到行尾结束。
    多行注释 - 以 :<<EOF 开头，到 EOF 结束。

💻 『示例源码』

#--------------------------------------------
# shell 注释示例
# author：zp
#--------------------------------------------

# echo '这是单行注释'

########## 这是分割线 ##########

:<<EOF
echo '这是多行注释'
echo '这是多行注释'
echo '这是多行注释'
EOF

echo

echo 用于字符串的输出。

输出普通字符串：

echo "hello, world"
# Output: hello, world

输出含变量的字符串：

echo "hello, \"zp\""
# Output: hello, "zp"

输出含变量的字符串：

name=zp
echo "hello, \"${name}\""
# Output: hello, "zp"

输出含换行符的字符串：

# 输出含换行符的字符串
echo "YES\nNO"
#  Output: YES\nNO

echo -e "YES\nNO" # -e 开启转义
#  Output:
#  YES
#  NO

输出含不换行符的字符串：

echo "YES"
echo "NO"
#  Output:
#  YES
#  NO

echo -e "YES\c" # -e 开启转义 \c 不换行
echo "NO"
#  Output:
#  YESNO

输出重定向至文件

echo "test" > test.txt

输出执行结果

echo `pwd`
#  Output:(当前目录路径)

💻 『示例源码』

#!/usr/bin/env bash

# 输出普通字符串
echo "hello, world"
#  Output: hello, world

# 输出含变量的字符串
echo "hello, \"zp\""
#  Output: hello, "zp"

# 输出含变量的字符串
name=zp
echo "hello, \"${name}\""
#  Output: hello, "zp"

# 输出含换行符的字符串
echo "YES\nNO"
#  Output: YES\nNO
echo -e "YES\nNO" # -e 开启转义
#  Output:
#  YES
#  NO

# 输出含不换行符的字符串
echo "YES"
echo "NO"
#  Output:
#  YES
#  NO

echo -e "YES\c" # -e 开启转义 \c 不换行
echo "NO"
#  Output:
#  YESNO

# 输出内容定向至文件
echo "test" > test.txt

# 输出执行结果
echo `pwd`
#  Output:(当前目录路径)

printf

printf 用于格式化输出字符串。

默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 \n。

💻 『示例源码』

# 单引号
printf '%d %s\n' 1 "abc"
#  Output:1 abc

# 双引号
printf "%d %s\n" 1 "abc"
#  Output:1 abc

# 无引号
printf %s abcdef
#  Output: abcdef(并不会换行)

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出
printf "%s\n" abc def
#  Output:
#  abc
#  def

printf "%s %s %s\n" a b c d e f g h i j
#  Output:
#  a b c
#  d e f
#  g h i
#  j

# 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替
printf "%s and %d \n"
#  Output:
#   and 0

# 格式化输出
printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234
printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543
printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876
#  Output:
#  姓名     性别   体重kg
#  郭靖     男      66.12
#  杨过     男      48.65
#  郭芙     女      47.99

printf 的转义符
序列 	说明
\a 	警告字符，通常为 ASCII 的 BEL 字符
\b 	后退
\c 	抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
\f 	换页（formfeed）
\n 	换行
\r 	回车（Carriage return）
\t 	水平制表符
\v 	垂直制表符
\\ 	一个字面上的反斜杠字符
\ddd 	表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效
\0ddd 	表示 1 到 3 位的八进制值字符
变量

跟许多程序设计语言一样，你可以在 bash 中创建变量。

Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。
变量命名原则

    命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
    中间不能有空格，可以使用下划线（_）。
    不能使用标点符号。
    不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。

声明变量

访问变量的语法形式为：${var} 和 $var 。

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。

word="hello"
echo ${word}
# Output: hello

只读变量

使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

rword="hello"
echo ${rword}
readonly rword
# rword="bye"  # 如果放开注释，执行时会报错

删除变量

使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。

dword="hello"  # 声明变量
echo ${dword}  # 输出变量值
# Output: hello

unset dword    # 删除变量
echo ${dword}
# Output: （空）

变量类型

    局部变量 - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。
    环境变量 - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 export 关键字，shell 脚本也可以定义环境变量。

常见的环境变量：
变量 	描述
$HOME 	当前用户的用户目录
$PATH 	用分号分隔的目录列表，shell 会到这些目录中查找命令
$PWD 	当前工作目录
$RANDOM 	0 到 32767 之间的整数
$UID 	数值类型，当前用户的用户 ID
$PS1 	主要系统输入提示符
$PS2 	次要系统输入提示符

这里 有一张更全面的 Bash 环境变量列表。

💻 『示例源码』

#!/usr/bin/env bash

################### 声明变量 ###################
name="world"
echo "hello ${name}"
# Output: hello world

################### 输出变量 ###################
folder=$(pwd)
echo "current path: ${folder}"

################### 只读变量 ###################
rword="hello"
echo ${rword}
# Output: hello
readonly rword
# rword="bye"  # 如果放开注释，执行时会报错

################### 删除变量 ###################
dword="hello" # 声明变量
echo ${dword} # 输出变量值
# Output: hello

unset dword # 删除变量
echo ${dword}
# Output: （空）

################### 系统变量 ###################
echo "UID:$UID"
echo LOGNAME:$LOGNAME
echo User:$USER
echo HOME:$HOME
echo PATH:$PATH
echo HOSTNAME:$HOSTNAME
echo SHELL:$SHELL
echo LANG:$LANG

################### 自定义变量 ###################
days=10
user="admin"
echo "$user logged in $days days age"
days=5
user="root"
echo "$user logged in $days days age"
# Output:
# admin logged in 10 days age
# root logged in 5 days age

################### 从变量读取列表 ###################
colors="Red Yellow Blue"
colors=$colors" White Black"

for color in $colors
do
	echo " $color"
done

字符串
单引号和双引号

shell 字符串可以用单引号 ''，也可以用双引号 “”，也可以不用引号。

    单引号的特点
        单引号里不识别变量
        单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。
    双引号的特点
        双引号里识别变量
        双引号里可以出现转义字符

综上，推荐使用双引号。
拼接字符串

# 使用单引号拼接
name1='white'
str1='hello, '${name1}''
str2='hello, ${name1}'
echo ${str1}_${str2}
# Output:
# hello, white_hello, ${name1}

# 使用双引号拼接
name2="black"
str3="hello, "${name2}""
str4="hello, ${name2}"
echo ${str3}_${str4}
# Output:
# hello, black_hello, black

获取字符串长度

text="12345"
echo ${#text}
# Output:
# 5

截取子字符串

text="12345"
echo ${text:2:2}
# Output:
# 34

从第 3 个字符开始，截取 2 个字符
查找子字符串

#!/usr/bin/env bash

text="hello"
echo `expr index "${text}" ll`

# Execute: ./str-demo5.sh
# Output:
# 3

查找 ll 子字符在 hello 字符串中的起始位置。

💻 『示例源码』

#!/usr/bin/env bash

################### 使用单引号拼接字符串 ###################
name1='white'
str1='hello, '${name1}''
str2='hello, ${name1}'
echo ${str1}_${str2}
# Output:
# hello, white_hello, ${name1}

################### 使用双引号拼接字符串 ###################
name2="black"
str3="hello, "${name2}""
str4="hello, ${name2}"
echo ${str3}_${str4}
# Output:
# hello, black_hello, black

################### 获取字符串长度 ###################
text="12345"
echo "${text} length is: ${#text}"
# Output:
# 12345 length is: 5

# 获取子字符串
text="12345"
echo ${text:2:2}
# Output:
# 34

################### 查找子字符串 ###################
text="hello"
echo `expr index "${text}" ll`
# Output:
# 3

################### 判断字符串中是否包含子字符串 ###################
result=$(echo "${str}" | grep "feature/")
if [[ "$result" != "" ]]; then
	echo "feature/ 是 ${str} 的子字符串"
else
	echo "feature/ 不是 ${str} 的子字符串"
fi

################### 截取关键字左边内容 ###################
full_branch="feature/1.0.0"
branch=`echo ${full_branch#feature/}`
echo "branch is ${branch}"

################### 截取关键字右边内容 ###################
full_version="0.0.1-SNAPSHOT"
version=`echo ${full_version%-SNAPSHOT}`
echo "version is ${version}"

################### 字符串分割成数组 ###################
str="0.0.0.1"
OLD_IFS="$IFS"
IFS="."
array=( ${str} )
IFS="$OLD_IFS"
size=${#array[*]}
lastIndex=`expr ${size} - 1`
echo "数组长度：${size}"
echo "最后一个数组元素：${array[${lastIndex}]}"
for item in ${array[@]}
do
	echo "$item"
done

################### 判断字符串是否为空 ###################
#-n 判断长度是否非零
#-z 判断长度是否为零

str=testing
str2=''
if [[ -n "$str" ]]
then
	echo "The string $str is not empty"
else
	echo "The string $str is empty"
fi

if [[ -n "$str2" ]]
then
	echo "The string $str2 is not empty"
else
	echo "The string $str2 is empty"
fi

#	Output:
#	The string testing is not empty
#	The string  is empty

################### 字符串比较 ###################
str=hello
str2=world
if [[ $str = "hello" ]]; then
	echo "str equals hello"
else
	echo "str not equals hello"
fi

if [[ $str2 = "hello" ]]; then
	echo "str2 equals hello"
else
	echo "str2 not equals hello"
fi

数组

bash 只支持一维数组。

数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。
创建数组

# 创建数组的不同方式
nums=([2]=2 [0]=0 [1]=1)
colors=(red yellow "dark blue")

访问数组元素

    访问数组的单个元素：

echo ${nums[1]}
# Output: 1

    访问数组的所有元素：

echo ${colors[*]}
# Output: red yellow dark blue

echo ${colors[@]}
# Output: red yellow dark blue

上面两行有很重要（也很微妙）的区别：

为了将数组中每个元素单独一行输出，我们用 printf 命令：

printf "+ %s\n" ${colors[*]}
# Output:
# + red
# + yellow
# + dark
# + blue

为什么dark和blue各占了一行？尝试用引号包起来：

printf "+ %s\n" "${colors[*]}"
# Output:
# + red yellow dark blue

现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试${colors[@]}

printf "+ %s\n" "${colors[@]}"
# Output:
# + red
# + yellow
# + dark blue

在引号内，${colors[@]}将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。

    访问数组的部分元素：

echo ${nums[@]:0:2}
# Output:
# 0 1

在上面的例子中，${array[@]} 扩展为整个数组，:0:2取出了数组中从 0 开始，长度为 2 的元素。
访问数组长度

echo ${#nums[*]}
# Output:
# 3

向数组中添加元素

向数组中添加元素也非常简单：

colors=(white "${colors[@]}" green black)
echo ${colors[@]}
# Output:
# white red yellow dark blue green black

上面的例子中，${colors[@]} 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组colors的赋值覆盖了它原来的值。
从数组中删除元素

用unset命令来从数组中删除一个元素：

unset nums[0]
echo ${nums[@]}
# Output:
# 1 2

💻 『示例源码』

#!/usr/bin/env bash

################### 创建数组 ###################
nums=( [ 2 ] = 2 [ 0 ] = 0 [ 1 ] = 1 )
colors=( red yellow "dark blue" )

################### 访问数组的单个元素 ###################
echo ${nums[1]}
# Output: 1

################### 访问数组的所有元素 ###################
echo ${colors[*]}
# Output: red yellow dark blue

echo ${colors[@]}
# Output: red yellow dark blue

printf "+ %s\n" ${colors[*]}
# Output:
# + red
# + yellow
# + dark
# + blue

printf "+ %s\n" "${colors[*]}"
# Output:
# + red yellow dark blue

printf "+ %s\n" "${colors[@]}"
# Output:
# + red
# + yellow
# + dark blue

################### 访问数组的部分元素 ###################
echo ${nums[@]:0:2}
# Output:
# 0 1

################### 获取数组长度 ###################
echo ${#nums[*]}
# Output:
# 3

################### 向数组中添加元素 ###################
colors=( white "${colors[@]}" green black )
echo ${colors[@]}
# Output:
# white red yellow dark blue green black

################### 从数组中删除元素 ###################
unset nums[ 0 ]
echo ${nums[@]}
# Output:
# 1 2

运算符
算术运算符

下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：
运算符 	说明 	举例
+ 	加法 	expr $x + $y 结果为 30。
- 	减法 	expr $x - $y 结果为 -10。
* 	乘法 	expr $x * $y 结果为 200。
/ 	除法 	expr $y / $x 结果为 2。
% 	取余 	expr $y % $x 结果为 0。
= 	赋值 	x=$y 将把变量 y 的值赋给 x。
== 	相等。用于比较两个数字，相同则返回 true。 	[ $x == $y ] 返回 false。
!= 	不相等。用于比较两个数字，不相同则返回 true。 	[ $x != $y ] 返回 true。

**注意：**条件表达式要放在方括号之间，并且要有空格，例如: [$x==$y] 是错误的，必须写成 [ $x == $y ]。

💻 『示例源码』

x=10
y=20

echo "x=${x}, y=${y}"

val=`expr ${x} + ${y}`
echo "${x} + ${y} = $val"

val=`expr ${x} - ${y}`
echo "${x} - ${y} = $val"

val=`expr ${x} \* ${y}`
echo "${x} * ${y} = $val"

val=`expr ${y} / ${x}`
echo "${y} / ${x} = $val"

val=`expr ${y} % ${x}`
echo "${y} % ${x} = $val"

if [[ ${x} == ${y} ]]
then
  echo "${x} = ${y}"
fi
if [[ ${x} != ${y} ]]
then
  echo "${x} != ${y}"
fi

#  Output:
#  x=10, y=20
#  10 + 20 = 30
#  10 - 20 = -10
#  10 * 20 = 200
#  20 / 10 = 2
#  20 % 10 = 0
#  10 != 20

关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：
运算符 	说明 	举例
-eq 	检测两个数是否相等，相等返回 true。 	[ $a -eq $b ]返回 false。
-ne 	检测两个数是否相等，不相等返回 true。 	[ $a -ne $b ] 返回 true。
-gt 	检测左边的数是否大于右边的，如果是，则返回 true。 	[ $a -gt $b ] 返回 false。
-lt 	检测左边的数是否小于右边的，如果是，则返回 true。 	[ $a -lt $b ] 返回 true。
-ge 	检测左边的数是否大于等于右边的，如果是，则返回 true。 	[ $a -ge $b ] 返回 false。
-le 	检测左边的数是否小于等于右边的，如果是，则返回 true。 	[ $a -le $b ]返回 true。

💻 『示例源码』

x=10
y=20

echo "x=${x}, y=${y}"

if [[ ${x} -eq ${y} ]]; then
   echo "${x} -eq ${y} : x 等于 y"
else
   echo "${x} -eq ${y}: x 不等于 y"
fi

if [[ ${x} -ne ${y} ]]; then
   echo "${x} -ne ${y}: x 不等于 y"
else
   echo "${x} -ne ${y}: x 等于 y"
fi

if [[ ${x} -gt ${y} ]]; then
   echo "${x} -gt ${y}: x 大于 y"
else
   echo "${x} -gt ${y}: x 不大于 y"
fi

if [[ ${x} -lt ${y} ]]; then
   echo "${x} -lt ${y}: x 小于 y"
else
   echo "${x} -lt ${y}: x 不小于 y"
fi

if [[ ${x} -ge ${y} ]]; then
   echo "${x} -ge ${y}: x 大于或等于 y"
else
   echo "${x} -ge ${y}: x 小于 y"
fi

if [[ ${x} -le ${y} ]]; then
   echo "${x} -le ${y}: x 小于或等于 y"
else
   echo "${x} -le ${y}: x 大于 y"
fi

#  Output:
#  x=10, y=20
#  10 -eq 20: x 不等于 y
#  10 -ne 20: x 不等于 y
#  10 -gt 20: x 不大于 y
#  10 -lt 20: x 小于 y
#  10 -ge 20: x 小于 y
#  10 -le 20: x 小于或等于 y

布尔运算符

下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：
运算符 	说明 	举例
! 	非运算，表达式为 true 则返回 false，否则返回 true。 	[ ! false ] 返回 true。
-o 	或运算，有一个表达式为 true 则返回 true。 	[ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a 	与运算，两个表达式都为 true 才返回 true。 	[ $a -lt 20 -a $b -gt 100 ] 返回 false。

💻 『示例源码』

x=10
y=20

echo "x=${x}, y=${y}"

if [[ ${x} != ${y} ]]; then
   echo "${x} != ${y} : x 不等于 y"
else
   echo "${x} != ${y}: x 等于 y"
fi

if [[ ${x} -lt 100 && ${y} -gt 15 ]]; then
   echo "${x} 小于 100 且 ${y} 大于 15 : 返回 true"
else
   echo "${x} 小于 100 且 ${y} 大于 15 : 返回 false"
fi

if [[ ${x} -lt 100 || ${y} -gt 100 ]]; then
   echo "${x} 小于 100 或 ${y} 大于 100 : 返回 true"
else
   echo "${x} 小于 100 或 ${y} 大于 100 : 返回 false"
fi

if [[ ${x} -lt 5 || ${y} -gt 100 ]]; then
   echo "${x} 小于 5 或 ${y} 大于 100 : 返回 true"
else
   echo "${x} 小于 5 或 ${y} 大于 100 : 返回 false"
fi

#  Output:
#  x=10, y=20
#  10 != 20 : x 不等于 y
#  10 小于 100 且 20 大于 15 : 返回 true
#  10 小于 100 或 20 大于 100 : 返回 true
#  10 小于 5 或 20 大于 100 : 返回 false

逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:
运算符 	说明 	举例
&& 	逻辑的 AND 	[[ ${x} -lt 100 && ${y} -gt 100 ]] 返回 false
` 		`

💻 『示例源码』

x=10
y=20

echo "x=${x}, y=${y}"

if [[ ${x} -lt 100 && ${y} -gt 100 ]]
then
   echo "${x} -lt 100 && ${y} -gt 100 返回 true"
else
   echo "${x} -lt 100 && ${y} -gt 100 返回 false"
fi

if [[ ${x} -lt 100 || ${y} -gt 100 ]]
then
   echo "${x} -lt 100 || ${y} -gt 100 返回 true"
else
   echo "${x} -lt 100 || ${y} -gt 100 返回 false"
fi

#  Output:
#  x=10, y=20
#  10 -lt 100 && 20 -gt 100 返回 false
#  10 -lt 100 || 20 -gt 100 返回 true

字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：
运算符 	说明 	举例
= 	检测两个字符串是否相等，相等返回 true。 	[ $a = $b ] 返回 false。
!= 	检测两个字符串是否相等，不相等返回 true。 	[ $a != $b ] 返回 true。
-z 	检测字符串长度是否为 0，为 0 返回 true。 	[ -z $a ] 返回 false。
-n 	检测字符串长度是否为 0，不为 0 返回 true。 	[ -n $a ] 返回 true。
str 	检测字符串是否为空，不为空返回 true。 	[ $a ] 返回 true。

💻 『示例源码』

x="abc"
y="xyz"


echo "x=${x}, y=${y}"

if [[ ${x} = ${y} ]]; then
   echo "${x} = ${y} : x 等于 y"
else
   echo "${x} = ${y}: x 不等于 y"
fi

if [[ ${x} != ${y} ]]; then
   echo "${x} != ${y} : x 不等于 y"
else
   echo "${x} != ${y}: x 等于 y"
fi

if [[ -z ${x} ]]; then
   echo "-z ${x} : 字符串长度为 0"
else
   echo "-z ${x} : 字符串长度不为 0"
fi

if [[ -n "${x}" ]]; then
   echo "-n ${x} : 字符串长度不为 0"
else
   echo "-n ${x} : 字符串长度为 0"
fi

if [[ ${x} ]]; then
   echo "${x} : 字符串不为空"
else
   echo "${x} : 字符串为空"
fi

#  Output:
#  x=abc, y=xyz
#  abc = xyz: x 不等于 y
#  abc != xyz : x 不等于 y
#  -z abc : 字符串长度不为 0
#  -n abc : 字符串长度不为 0
#  abc : 字符串不为空

文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

属性检测描述如下：
操作符 	说明 	举例
-b file 	检测文件是否是块设备文件，如果是，则返回 true。 	[ -b $file ] 返回 false。
-c file 	检测文件是否是字符设备文件，如果是，则返回 true。 	[ -c $file ] 返回 false。
-d file 	检测文件是否是目录，如果是，则返回 true。 	[ -d $file ] 返回 false。
-f file 	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 	[ -f $file ] 返回 true。
-g file 	检测文件是否设置了 SGID 位，如果是，则返回 true。 	[ -g $file ] 返回 false。
-k file 	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 	[ -k $file ]返回 false。
-p file 	检测文件是否是有名管道，如果是，则返回 true。 	[ -p $file ] 返回 false。
-u file 	检测文件是否设置了 SUID 位，如果是，则返回 true。 	[ -u $file ] 返回 false。
-r file 	检测文件是否可读，如果是，则返回 true。 	[ -r $file ] 返回 true。
-w file 	检测文件是否可写，如果是，则返回 true。 	[ -w $file ] 返回 true。
-x file 	检测文件是否可执行，如果是，则返回 true。 	[ -x $file ] 返回 true。
-s file 	检测文件是否为空（文件大小是否大于 0），不为空返回 true。 	[ -s $file ] 返回 true。
-e file 	检测文件（包括目录）是否存在，如果是，则返回 true。 	[ -e $file ] 返回 true。

💻 『示例源码』

file="/etc/hosts"

if [[ -r ${file} ]]; then
   echo "${file} 文件可读"
else
   echo "${file} 文件不可读"
fi
if [[ -w ${file} ]]; then
   echo "${file} 文件可写"
else
   echo "${file} 文件不可写"
fi
if [[ -x ${file} ]]; then
   echo "${file} 文件可执行"
else
   echo "${file} 文件不可执行"
fi
if [[ -f ${file} ]]; then
   echo "${file} 文件为普通文件"
else
   echo "${file} 文件为特殊文件"
fi
if [[ -d ${file} ]]; then
   echo "${file} 文件是个目录"
else
   echo "${file} 文件不是个目录"
fi
if [[ -s ${file} ]]; then
   echo "${file} 文件不为空"
else
   echo "${file} 文件为空"
fi
if [[ -e ${file} ]]; then
   echo "${file} 文件存在"
else
   echo "${file} 文件不存在"
fi

#  Output:(根据文件的实际情况，输出结果可能不同)
#  /etc/hosts 文件可读
#  /etc/hosts 文件可写
#  /etc/hosts 文件不可执行
#  /etc/hosts 文件为普通文件
#  /etc/hosts 文件不是个目录
#  /etc/hosts 文件不为空
#  /etc/hosts 文件存在

控制语句
条件语句

跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在[[ ]]里的表达式。

由[[ ]]（sh中是[ ]）包起来的表达式被称作 检测命令 或 基元。这些表达式帮助我们检测一个条件的结果。这里可以找到有关bash 中单双中括号区别的答案。

共有两个不同的条件表达式：if和case。
if

（1）if 语句

if在使用上跟其它语言相同。如果中括号里的表达式为真，那么then和fi之间的代码会被执行。fi标志着条件代码块的结束。

# 写成一行
if [[ 1 -eq 1 ]]; then echo "1 -eq 1 result is: true"; fi
# Output: 1 -eq 1 result is: true

# 写成多行
if [[ "abc" -eq "abc" ]]
then
  echo ""abc" -eq "abc" result is: true"
fi
# Output: abc -eq abc result is: true

（2）if else 语句

同样，我们可以使用if..else语句，例如：

if [[ 2 -ne 1 ]]; then
  echo "true"
else
  echo "false"
fi
# Output: true

（3）if elif else 语句

有些时候，if..else不能满足我们的要求。别忘了if..elif..else，使用起来也很方便。

💻 『示例源码』

x=10
y=20
if [[ ${x} > ${y} ]]; then
   echo "${x} > ${y}"
elif [[ ${x} < ${y} ]]; then
   echo "${x} < ${y}"
else
   echo "${x} = ${y}"
fi
# Output: 10 < 20

case

如果你需要面对很多情况，分别要采取不同的措施，那么使用case会比嵌套的if更有用。使用case来解决复杂的条件判断，看起来像下面这样：

💻 『示例源码』

case ${oper} in
  "+")
    val=`expr ${x} + ${y}`
    echo "${x} + ${y} = ${val}"
  ;;
  "-")
    val=`expr ${x} - ${y}`
    echo "${x} - ${y} = ${val}"
  ;;
  "*")
    val=`expr ${x} \* ${y}`
    echo "${x} * ${y} = ${val}"
  ;;
  "/")
    val=`expr ${x} / ${y}`
    echo "${x} / ${y} = ${val}"
  ;;
  *)
    echo "Unknown oper!"
  ;;
esac

每种情况都是匹配了某个模式的表达式。|用来分割多个模式，)用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。*代表任何不匹配以上给定模式的模式。命令块儿之间要用;;分隔。
循环语句

循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。

Bash 中有四种循环：for，while，until和select。
for循环

for与它在 C 语言中的姊妹非常像。看起来是这样：

for arg in elem1 elem2 ... elemN
do
  ### 语句
done

在每次循环的过程中，arg依次被赋值为从elem1到elemN。这些值还可以是通配符或者大括号扩展。

当然，我们还可以把for循环写在一行，但这要求do之前要有一个分号，就像下面这样：

for i in {1..5}; do echo $i; done

还有，如果你觉得for..in..do对你来说有点奇怪，那么你也可以像 C 语言那样使用for，比如：

for (( i = 0; i < 10; i++ )); do
  echo $i
done

当我们想对一个目录下的所有文件做同样的操作时，for就很方便了。举个例子，如果我们想把所有的.bash文件移动到script文件夹中，并给它们可执行权限，我们的脚本可以这样写：

💻 『示例源码』

DIR=/home/zp
for FILE in ${DIR}/*.sh; do
  mv "$FILE" "${DIR}/scripts"
done
# 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts

while循环

while循环检测一个条件，只要这个条件为 真，就执行一段命令。被检测的条件跟if..then中使用的基元并无二异。因此一个while循环看起来会是这样：

while [[ condition ]]
do
  ### 语句
done

跟for循环一样，如果我们把do和被检测的条件写到一行，那么必须要在do之前加一个分号。

💻 『示例源码』

### 0到9之间每个数的平方
x=0
while [[ ${x} -lt 10 ]]; do
  echo $((x * x))
  x=$((x + 1))
done
#  Output:
#  0
#  1
#  4
#  9
#  16
#  25
#  36
#  49
#  64
#  81

until循环

until循环跟while循环正好相反。它跟while一样也需要检测一个测试条件，但不同的是，只要该条件为 假 就一直执行循环：

💻 『示例源码』

x=0
until [[ ${x} -ge 5 ]]; do
  echo ${x}
  x=`expr ${x} + 1`
done
#  Output:
#  0
#  1
#  2
#  3
#  4

select循环

select循环帮助我们组织一个用户菜单。它的语法几乎跟for循环一致：

select answer in elem1 elem2 ... elemN
do
  ### 语句
done

select会打印elem1..elemN以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是$?（PS3变量）。用户的选择结果会被保存到answer中。
如果answer是一个在1..N之间的数字，那么语句会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用break语句。

💻 『示例源码』

#!/usr/bin/env bash

PS3="Choose the package manager: "
select ITEM in bower npm gem pip
do
echo -n "Enter the package name: " && read PACKAGE
case ${ITEM} in
  bower) bower install ${PACKAGE} ;;
  npm) npm install ${PACKAGE} ;;
  gem) gem install ${PACKAGE} ;;
  pip) pip install ${PACKAGE} ;;
esac
break # 避免无限循环
done

这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。

运行这个脚本，会得到如下输出：

$ ./my_script
1) bower
2) npm
3) gem
4) pip
Choose the package manager: 2
Enter the package name: gitbook-cli

break 和 continue

如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的break和continue语句来实现。它们可以在任何循环中使用。

    break语句用来提前结束当前循环。

    continue语句用来跳过某次迭代。

💻 『示例源码』

# 查找 10 以内第一个能整除 2 和 3 的正整数
i=1
while [[ ${i} -lt 10 ]]; do
  if [[ $((i % 3)) -eq 0 ]] && [[ $((i % 2)) -eq 0 ]]; then
    echo ${i}
    break;
  fi
  i=`expr ${i} + 1`
done
# Output: 6

💻 『示例源码』

# 打印10以内的奇数
for (( i = 0; i < 10; i ++ )); do
  if [[ $((i % 2)) -eq 0 ]]; then
    continue;
  fi
  echo ${i}
done
#  Output:
#  1
#  3
#  5
#  7
#  9

函数

bash 函数定义语法如下：

[ function ] funname [()] {
    action;
    [return int;]
}

    💡 说明：

        函数定义时，function 关键字可有可无。
        函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。
        函数返回值在调用该函数后通过 $? 来获得。
        所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。

💻 『示例源码』

#!/usr/bin/env bash

calc(){
  PS3="choose the oper: "
  select oper in + - \* / # 生成操作符选择菜单
  do
  echo -n "enter first num: " && read x # 读取输入参数
  echo -n "enter second num: " && read y # 读取输入参数
  case ${oper} in
    "+")
      return $((${x} + ${y}))
    ;;
    "-")
      return $((${x} - ${y}))
    ;;
    "*")
      return $((${x} * ${y}))
    ;;
    "/")
      return $((${x} / ${y}))
    ;;
    *)
      echo "${oper} is not support!"
      return 0
    ;;
  esac
  break
  done
}
calc
echo "the result is: $?" # $? 获取 calc 函数返回值

执行结果：

$ ./function-demo.sh
1) +
2) -
3) *
4) /
choose the oper: 3
enter first num: 10
enter second num: 10
the result is: 100

位置参数

位置参数是在调用一个函数并传给它参数时创建的变量。

位置参数变量表：
变量 	描述
$0 	脚本名称
$1 … $9 	第 1 个到第 9 个参数列表
${10} … ${N} 	第 10 个到 N 个参数列表
$* or $@ 	除了$0外的所有位置参数
$# 	不包括$0在内的位置参数的个数
$FUNCNAME 	函数名称（仅在函数内部有值）

💻 『示例源码』

#!/usr/bin/env bash

x=0
if [[ -n $1 ]]; then
  echo "第一个参数为：$1"
  x=$1
else
  echo "第一个参数为空"
fi

y=0
if [[ -n $2 ]]; then
  echo "第二个参数为：$2"
  y=$2
else
  echo "第二个参数为空"
fi

paramsFunction(){
  echo "函数第一个入参：$1"
  echo "函数第二个入参：$2"
}
paramsFunction ${x} ${y}

执行结果：

$ ./function-demo2.sh
第一个参数为空
第二个参数为空
函数第一个入参：0
函数第二个入参：0

$ ./function-demo2.sh 10 20
第一个参数为：10
第二个参数为：20
函数第一个入参：10
函数第二个入参：20

执行 ./variable-demo4.sh hello world ，然后在脚本中通过 $1、$2 ... 读取第 1 个参数、第 2 个参数。。。
函数处理参数

另外，还有几个特殊字符用来处理参数：
参数处理 	说明
$# 	返回参数个数
$* 	返回所有参数
$$ 	脚本运行的当前进程 ID 号
$! 	后台运行的最后一个进程的 ID 号
$@ 	返回所有参数
$- 	返回 Shell 使用的当前选项，与 set 命令功能相同。
$? 	函数返回值

💻 『示例源码』

runner() {
  return 0
}

name=zp
paramsFunction(){
  echo "函数第一个入参：$1"
  echo "函数第二个入参：$2"
  echo "传递到脚本的参数个数：$#"
  echo "所有参数："
  printf "+ %s\n" "$*"
  echo "脚本运行的当前进程 ID 号：$$"
  echo "后台运行的最后一个进程的 ID 号：$!"
  echo "所有参数："
  printf "+ %s\n" "$@"
  echo "Shell 使用的当前选项：$-"
  runner
  echo "runner 函数的返回值：$?"
}
paramsFunction 1 "abc" "hello, \"zp\""
#  Output:
#  函数第一个入参：1
#  函数第二个入参：abc
#  传递到脚本的参数个数：3
#  所有参数：
#  + 1 abc hello, "zp"
#  脚本运行的当前进程 ID 号：26400
#  后台运行的最后一个进程的 ID 号：
#  所有参数：
#  + 1
#  + abc
#  + hello, "zp"
#  Shell 使用的当前选项：hB
#  runner 函数的返回值：0

Shell 扩展

扩展 发生在一行命令被分成一个个的 记号（tokens） 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。

感兴趣的话可以阅读关于 shell 扩展的更多细节。
大括号扩展

大括号扩展让生成任意的字符串成为可能。它跟 文件名扩展 很类似，举个例子：

echo beg{i,a,u}n ### begin began begun

大括号扩展还可以用来创建一个可被循环迭代的区间。

echo {0..5} ### 0 1 2 3 4 5
echo {00..8..2} ### 00 02 04 06 08

命令置换

命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或$()包围时，命令置换将会执行。举个例子：

now=`date +%T`
### or
now=$(date +%T)

echo $now ### 19:08:26

算数扩展

在 bash 中，执行算数运算是非常方便的。算数表达式必须包在$(( ))中。算数扩展的格式为：

result=$(( ((10 + 5*3) - 7) / 2 ))
echo $result ### 9

在算数表达式中，使用变量无需带上$前缀：

x=4
y=7
echo $(( x + y ))     ### 11
echo $(( ++x + y++ )) ### 12
echo $(( x + y ))     ### 13

单引号和双引号

单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：

echo "Your home: $HOME" ### Your home: /Users/<username>
echo 'Your home: $HOME' ### Your home: $HOME

当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用echo来输出用户的输入：

INPUT="A string  with   strange    whitespace."
echo $INPUT   ### A string with strange whitespace.
echo "$INPUT" ### A string  with   strange    whitespace.

调用第一个echo时给了它 5 个单独的参数 —— $INPUT 被分成了单独的词，echo在每个词之间打印了一个空格。第二种情况，调用echo时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。

来看一个更严肃的例子：

FILE="Favorite Things.txt"
cat $FILE   ### 尝试输出两个文件: `Favorite` 和 `Things.txt`
cat "$FILE" ### 输出一个文件: `Favorite Things.txt`

尽管这个问题可以通过把 FILE 重命名成Favorite-Things.txt来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（find, cat, 等等）呢。因此，如果输入 可能 包含空格，务必要用引号把表达式包起来。
流和重定向

Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。

管道给了我们创建传送带的机会，控制程序的执行成为可能。

学习如何使用这些强大的、高级的工具是非常非常重要的。
输入、输出流

Bash 接收输入，并以字符序列或 字符流 的形式产生输出。这些流能被重定向到文件或另一个流中。

有三个文件描述符：
代码 	描述符 	描述
0 	stdin 	标准输入
1 	stdout 	标准输出
2 	stderr 	标准错误输出
重定向

重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：
Operator 	Description
> 	重定向输出
&> 	重定向输出和错误输出
&>> 	以附加的形式重定向输出和错误输出
< 	重定向输入
<< 	Here 文档 语法
<<< 	Here 字符串

以下是一些使用重定向的例子：

### ls的结果将会被写到list.txt中
ls -l > list.txt

### 将输出附加到list.txt中
ls -a >> list.txt

### 所有的错误信息会被写到errors.txt中
grep da * 2> errors.txt

### 从errors.txt中读取输入
less < errors.txt

/dev/null 文件

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

$ command > /dev/null

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

$ command > /dev/null 2>&1

Debug

shell 提供了用于 debug 脚本的工具。

如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：

#!/bin/bash options

options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：
Short 	Name 	Description
-f 	noglob 	禁止文件名展开（globbing）
-i 	interactive 	让脚本以 交互 模式运行
-n 	noexec 	读取命令，但不执行（语法检查）
-t 	— 	执行完第一条命令后退出
-v 	verbose 	在执行每条命令前，向stderr输出该命令
-x 	xtrace 	在执行每条命令前，向stderr输出该命令以及该命令的扩展参数

举个例子，如果我们在脚本中指定了-x例如：

#!/bin/bash -x

for (( i = 0; i < 3; i++ )); do
  echo $i
done

这会向stdout打印出变量的值和一些其它有用的信息：

$ ./my_script
+ (( i = 0 ))
+ (( i < 3 ))
+ echo 0
0
+ (( i++  ))
+ (( i < 3 ))
+ echo 1
1
+ (( i++  ))
+ (( i < 3 ))
+ echo 2
2
+ (( i++  ))
+ (( i < 3 ))

有时我们值需要 debug 脚本的一部分。这种情况下，使用set命令会很方便。这个命令可以启用或禁用选项。使用-启用选项，+禁用选项：

💻 『示例源码』

# 开启 debug
set -x
for (( i = 0; i < 3; i++ )); do
  printf ${i}
done
# 关闭 debug
set +x
#  Output:
#  + (( i = 0 ))
#  + (( i < 3 ))
#  + printf 0
#  0+ (( i++  ))
#  + (( i < 3 ))
#  + printf 1
#  1+ (( i++  ))
#  + (( i < 3 ))
#  + printf 2
#  2+ (( i++  ))
#  + (( i < 3 ))
#  + set +x

for i in {1..5}; do printf ${i}; done
printf "\n"
#  Output: 12345

资源

    awesome-shell - shell 资源列表
    awesome-bash - bash 资源列表
    bash-handbook
    bash-guide - bash 基本用法指南
    bash-it - 为你日常使用、开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架
    dotfiles.github.io - 上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接
    Runoob Shell 教程
    shellcheck - 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。

最后，Stack Overflow 上 bash 标签下有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。
